<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>C++ 17 february</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h1 id="прерывания">Прерывания</h1>
<p>Почему программа с вечным циклом не повесит нам весь компьютер? (даже если 1 ядро)<br>
Как ОС работает с устройствами?</p>
<ol>
<li><em>Polling</em> процессор сам спрашивает устройства, когда надо (пока не используется)</li>
<li><em>Interrupt</em>(прерывание) устройство само говорит об изменении, процессор вызывает обработка прерываний.</li>
</ol>
<p><strong>Local timer interrupt</strong> - делаем прерывание и ОС может сделать:</p>
<ol>
<li>Продолжить прогу</li>
<li>Сохранить состояние первой программы и запустить вторую</li>
</ol>
<p>Как ОС работает с памятью? Ядро ОС придерживается 2 принципов:</p>
<ol>
<li><em>hardware abstraction</em> (абстракция железку) (мышка может быть подключена по-разному подключенный но программе все равно)</li>
<li><em>isolation process</em> (изоляция программ) - программа не может повлиять на другие программы (записать в их память)</li>
</ol>
<p>Как это достигается:<br>
Виртуальная память: номер ячейки к которой обращается программа пересчитывается в физическую память.<br>
Ячейки памяти для программы - виртуальная память.<br>
Процесс преобразования из виртуальной в физическую называется <strong>страничной адресацией</strong>.</p>
<h2 id="страничная-адресация">Страничная адресация</h2>
<p><img src="https://lh3.googleusercontent.com/3bjis4tFuLLCGRN9sWvT--CDxBqX90ePws2PA10Z4dAEFjZoQ20rPxe9TD9CwHecKRbxU5wH1a9N" alt="иллюстрация разобщенности памяти процессов"><br>
Адресация реализуется через PageTables<br>
Корень дерева 512 эл-ов по 8 байт: либо “меня нету” (глубина обычно 3)<br>
<img src="https://lh3.googleusercontent.com/Ab3UYTM8rGYbDegvJgYfX0dwrEud8KBbuFzydkEnW-knxajrZrc0kdqI5hWLzacxnyVn51DxOMwl" alt="страничная адресация"></p>
<h2 id="механизм-процессора">Механизм процессора</h2>
<p>Примерчик<br>
virtual adress - 0x123456789A<br>
//TODO сделать</p>
<p>Дерево обычно не полное.<br>
Альтернативы:</p>
<ul>
<li>хештаблица - плохо взаимодействует с кэшем</li>
<li>поделим память на куски (сегменты) и сдвиг внутри сегмента.</li>
</ul>
<h1 id="кэш-branch-prediction-и-другое">Кэш, Branch prediction и другое</h1>
<p>Как работает <code>malloc - free</code>? ОС выделяет 4Кб и “откусывает” понемногу оттуда. Как “откусывает”?<br>
Уточним модель процессора:</p>
<pre><code>for i = 0..n				for i=0..n
	for j=0..n					for j=0..n
		a[i][j] = 0 				a[j][i] = 0
</code></pre>
<p>У этих 2 кодов большая разница из-за процессорного кэша.<br>
<strong>Кэши</strong> реализованы через хэштаблицы (дискр. размера) ключ - адрес памяти, значение - что лежит<br>
Линии кэша ~64байта : ассоциативность кэша - кол-во buckets.<br>
<strong>Аппаратное предсказане</strong> - подгрузка в кэш заранее</p>
<h2 id="конвейер-pipelining">Конвейер (Pipelining)</h2>
<p>Что мы делаем при условных переходах? Выполняем какую-то ветку и если угададли - ок, иначе отменим.<br>
<strong>Branch prediction</strong> - прогнозирование, выполняем одну ветку if, если не угадали - откатываем<br>
Компилятор/планировщик пытаются распарсить код.</p>
<blockquote>
<p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p>
</blockquote>
</div>
</body>

</html>
